WEB ВИЗУАЛИЗАТОР АЛГОРИТМОВ СОРТИРОВКИ

--------------------

№1. Описание реализации
Данный проект представляет собой полнофункциональное веб-приложение, реализованное по классической клиент-серверной архитектуре. Его основная цель — создание интерактивной среды для визуального изучения и анализа восьми ключевых алгоритмов сортировки.

Выбор технологического стека был обусловлен требованиями к наглядности, интерактивности, производительности и простоте развертывания:
Backend: Язык Python и микрофреймворк Flask. Python выбран благодаря своей лаконичности и наличию богатого набора библиотек для алгоритмических задач, а Flask — за свою минималистичность, гибкость и простоту создания RESTful API.
Frontend: Стандартная триада веб-технологий: HTML5 для структуры страницы, CSS3 для стилизации и создания адаптивного визуального дизайна, и чистый JavaScript (ES6+) для реализации динамической логики и анимации без использования тяжелых фреймворков. Для отрисовки графики используется элемент <canvas>.
Протокол взаимодействия: Взаимодействие между клиентом и сервером построено на асинхронных HTTP-запросах (AJAX) в формате JSON, что обеспечивает плавную работу интерфейса без необходимости перезагрузки страницы.
Общая архитектура приложения может быть представлена следующей схемой взаимодействия:
* Пользователь через графический интерфейс браузера инициирует действие (выбор алгоритма, запуск, остановку).
* Frontend (JavaScript) отправляет соответствующий HTTP-запрос на сервер.
* Backend (Flask) принимает запрос, выполняет соответствующую бизнес-логику (запуск алгоритма сортировки в отдельном потоке, обновление глобального состояния) и возвращает ответ.
* Frontend периодически (с помощью requestAnimationFrame) опрашивает сервер через эндпоинт /get-data для получения актуального состояния массива и индексов для подсветки, после чего перерисовывает визуализацию на <canvas>.
* Для управления длительными операциями сортировки без блокировки основного потока сервера и возможности их прерывания была реализована простая многопоточная модель с использованием модуля threading. Это позволяет пользователю взаимодействовать с интерфейсом (например, остановить сортировку или запросить новые данные) в то время, когда алгоритм еще выполняется.

--------------------

№2. Описание классов и методов.
Несмотря на то, что в представленной реализации не используется парадигма ООП в чистом виде, логическую структуру приложения можно разделить на следующие модули и компоненты.

1. Backend-модуль (Файл app.py на Flask):
Глобальное состояние (visualizer_data): Словарь, выступающий в роли единого источника истины о текущем состоянии системы. Хранит:
bars: Текущий массив чисел для сортировки.
running: Флаг выполнения, критический для управления потоками и отображением.
current_algorithm: Имя активного алгоритма.
sort_time: Замеренное время последней выполненной сортировки.
highlight_indices: Массив индексов элементов, которые должны быть подсвечены на текущем шаге (для визуализации сравнений и перестановок).
array_size: Текущий размер массива.
Методы-роуты (Flask endpoints):
index(): Отдает главную HTML-страницу.
start_sorting(algorithm): инициализирует данные, сбрасывает таймер и запускает выбранный алгоритм в отдельном потоке. Принимает параметр size для задания размера массива.
get_data(): Возвращает текущее состояние visualizer_data в формате JSON. Это ключевой эндпоинт для анимации.
stop_sorting(): Устанавливает флаг running в False, что приводит к корректному прерыванию работающего алгоритма.
shuffle_bars() и change_size(): Утилитарные методы для генерации нового массива и изменения его размера в неактивном состоянии.
Ядро алгоритмов: Восемь функций сортировки (bubble_sort(), quick_sort() и др.). Их особенность — инструментированный код: в стратегически важные точки (циклы сравнения, операции обмена, слияния) добавлены:
Обновление highlight_indices для передачи информации о текущей операции на фронтенд.
Вызов time.sleep(0.05) для искусственного замедления процесса, делающего его воспринимаемым для человека.
Проверка флага visualizer_data['running'] для возможности мгновенного прерывания.
Метод run_sorting_algorithm(algorithm): Функция-обертка, которая запускается в отдельном потоке. Она фиксирует время начала, вызывает нужную функцию сортировки, вычисляет общее время выполнения и финализирует состояние (сбрасывает флаг running и подсветку).

2. Frontend-модуль (HTML, CSS, JavaScript):
Структура (HTML): определяет основные блоки интерфейса: область визуализации (<canvas>), панель управления с кнопками алгоритмов и контроля, информационные панели, секцию с объяснениями.
Стилизация (CSS): реализует современный, адаптивный дизайн с использованием Flexbox/Grid, градиентов, полупрозрачных фонов (backdrop-filter: blur) для эффекта "морозного стекла", плавных переходов и теней для создания глубины. Стили кнопок визуально разделены по функциональным группам (алгоритмы, управление).
Логика и отрисовка (JavaScript):
fetchData(): Асинхронная функция для опроса сервера и получения данных состояния.
drawBars(data): Основная функция рендеринга. На основе полученного массива bars и списка highlight_indices рассчитывает размер и положение каждого столбца на холсте, рисует их, используя разные цвета для обычных и активных элементов. Также обновляет текстовую информацию на странице.
animate(): Главный цикл анимации, реализованный через requestAnimationFrame. Бесконечно (пока открыта страница) вызывает fetchData() и drawBars(), обеспечивая плавную (обычно 60 FPS) визуализацию.
Управляющие функции: startSorting(), stopSorting(), changeArraySize() — обрабатывают действия пользователя, отправляя соответствующие запросы на сервер.
toggleExplanation(): Логика для работы аккордеона с теоретическими пояснениями к каждому алгоритму.
Связь между модулями обеспечивается через четкий API. Фронтенд не содержит логики сортировки, а является "тонким клиентом", ответственным только за отображение и ввод пользователя. Вся бизнес-логика и вычисления изолированы на сервере.

--------------------

№3. Экспериментальная часть
Для демонстрации работоспособности приложения и сравнения алгоритмов был проведен ряд экспериментов. Критериями оценки стали: корректность сортировки, интерактивность и плавность визуализации, а также наблюдаемое время выполнения.
Условия эксперимента:
Аппаратная платформа: Персональный компьютер со средними характеристиками.
Используемые браузеры: Google Chrome, Mozilla Firefox.
Тестовые наборы данных: массивы размером N=30, N=50 и N=80 элементов со случайными значениями в диапазоне [10, 280].
Фиксированная задержка time.sleep(0.05) в коде алгоритмов для синхронизации с анимацией.

Результаты и наблюдения:
Корректность работы: Все восемь реализованных алгоритмов успешно сортируют предложенные массивы в порядке возрастания. Визуализация корректно отображает ключевые этапы: для bubble_sort() видно попарное "всплытие" элементов, для quick_sort() — разделение относительно опорного, для merge_sort() — процесс слияния отсортированных подмассивов.

Визуальное восприятие:
Квадратичные алгоритмы (Bubble, Selection, Insertion): при N=80 становятся заметно медленными. Наблюдается большое количество пошаговых операций, что наглядно демонстрирует их неэффективность на больших данных. Сортировка выбором визуально отличается редкими, но "дальними" перестановками минимального элемента.
Эффективные алгоритмы (Quick, Merge, Heap): даже с искусственной задержкой завершают сортировку N=80 элементов в разы быстрее квадратичных. Визуально процесс выглядит более "хаотичным" и быстрым, особенно у Quick Sort, что отражает его принцип "разделяй и властвуй".
Специальный алгоритм (Counting): работает практически мгновенно даже на N=100, так как его сложность O(n+k) и внутренние циклы не содержат операций сравнения. Это наглядно показывает преимущество непомещающих сортировок в подходящих условиях (малый диапазон данных).
Интерактивность и управление:
Функции "Остановить" и "Перемешать" работают корректно. Прерывание алгоритма происходит практически мгновенно благодаря проверке флага running в каждой итерации.
Динамическое изменение размера массива в реальном времени позволяет наблюдать, как рост N влияет на время и сложность визуализируемого процесса. Увеличение размера с 30 до 80 для пузырьковой сортировки приводит к очевидно непропорциональному увеличению времени.
Система остается отзывчивой во время выполнения сортировки благодаря многопоточности на сервере и асинхронным запросам на клиенте.
Выводы экспериментальной части: Приложение успешно выполняет свою образовательную функцию. Оно не только корректно реализует алгоритмы, но и эффективно визуализирует принципиальную разницу в их работе, сложности и производительности, превращая абстрактные понятия "O(n²)" и "O(n log n)" в конкретное, наблюдаемое поведение. Пользователь получает возможность интерактивно исследовать, как разные алгоритмы ведут себя на одних и тех же данных.

--------------------

№4. Заключение.
В ходе практической работы было успешно разработано и протестировано веб-приложение для визуализации алгоритмов сортировки. Поставленные задачи выполнены в полном объеме:
Теоретические основы изучены и систематизированы — на их основе выбран репрезентативный набор из восьми алгоритмов, охватывающих основные классы по сложности и методу работы.
Реализация алгоритмов на Python проведена корректно. Код алгоритмов не только функционален, но и инструментирован для целей визуализации, что является ключевым отличием от академических реализаций.

Сайт создан и обладает полным набором заявленных функций:
* Интуитивно понятный и эстетичный интерфейс.
* Плавная анимация процесса сортировки в реальном времени с цветовой индикацией активных операций.
* Полный контроль пользователя над процессом (запуск, пауза, изменение параметров).
* Информационная панель с отображением текущего алгоритма, времени работы и размера массива.
* Встроенная справочная система с краткими объяснениями и сложностью каждого алгоритма.
Архитектурные решения (клиент-серверная модель с API, многопоточность на бэкенде, анимация на requestAnimationFrame на фронтенде) доказали свою эффективность, обеспечив стабильную, отзывчивую работу приложения и четкое разделение ответственности между компонентами.
Основные достижения:
* Создан законченный, готовый к использованию образовательный продукт.
* Достигнута главная цель — преодоление разрыва между теорией и практикой в изучении алгоритмов. Абстрактные операции сравнения и перемещения стали осязаемыми.
* Реализован принцип сравнительного анализа "здесь и сейчас", позволяющий в режиме реального времени оценить эффективность разных подходов.
Возможные направления для развития:
* Добавление графиков сравнения времени выполнения алгоритмов на разных размерах входных данных.

--------------------

Итоговая таблица соответствия требованиям:
Требование	Соответствие в коде	Комментарий
Функционал		
1. Хранение данных	Да (в памяти)	Временное хранение в структуре данных Python.
2. Визуализация	Да (полностью)	Столбчатая диаграмма с подсветкой и информационной панелью.
3. Поиск	Нет	Функционал не предусмотрен.
4. Управление	Частично	Управление процессом сортировки есть. Управление доступом отсутствует.
Реализация		
1. Вид реализации	Веб-приложение	Клиент-серверная архитектура, доступ из браузера.
2. Платформа	Кроссплатформенно	Для клиента — браузер, для сервера — любая ОС с Python.
3. СУБД	Нет	Постоянная база данных не используется.
4. Языки программирования	(Python, JS, HTML, CSS)	Python (Flask) на backend, веб-технологии на frontend.


Реализация других классов алгоритмов (поразрядная сортировка, Timsort).
Введение возможности загружать пользовательские наборы данных.
Улучшение детализации визуализации, например, отображение стека вызовов для рекурсивных алгоритмов или состояния кучи для Heap Sort.
Таким образом, практическая часть работы подтвердила, что интерактивная визуализация является мощным инструментом в образовательном процессе, а реализованное приложение служит успешным примером применения веб-технологий для решения задач наглядного обучения фундаментальным разделам информатики.

--------------------

СОРТИРОВКИ.
1. Сортировка пузырьком.
Многократно проходим по массиву и меняем местами соседние элементы, если они стоят не в порядке возрастания. Самые большие элементы «всплывают» к концу массива. Медленный, но простой.
2. Сортировка выбором.
Ищем минимальный элемент в неотсортированной части массива и меняем его с первым элементом этой части. Так постепенно формируем отсортированную часть слева направо.
3. Сортировка вставками.
Берём каждый следующий элемент и вставляем его в уже отсортированную часть массива на нужное место, сдвигая элементы при необходимости. Быстро работает на почти упорядоченных данных.
4. Сортировка Шелла.
Улучшенная версия сортировки вставками: сравниваем элементы, стоящие не рядом, а на определённом расстоянии (шаге), постепенно уменьшая шаг до 1. Ускоряет перемещение элементов.
5. Быстрая сортировка.
Выбираем опорный элемент, переставляем элементы так, чтобы слева были меньше опорного, а справа — больше. Затем рекурсивно сортируем обе части. Обычно самый быстрый на практике.
6. Сортировка слиянием.
Рекурсивно делим массив пополам, пока не получим отдельные элементы, затем сливаем пары в отсортированные массивы. Гарантированно быстрая, но требует дополнительной памяти.
7. Пирамидальная сортировка.
Превращаем массив в структуру «куча» (дерево), где родитель больше детей. Затем последовательно извлекаем максимальный элемент и перестраиваем кучу. Быстрая и без дополнительной памяти.
8. Сортировка подсчётом.
Подсчитываем, сколько раз встречается каждое число из заданного диапазона, а затем формируем отсортированный массив на основе этих подсчётов. Очень быстрая, но только для целых чисел с небольшим диапазоном значений.



